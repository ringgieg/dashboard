<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RuleQueryScheduler æµ‹è¯•</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 30px;
    }

    h1 {
      color: #333;
      margin-bottom: 20px;
      border-bottom: 3px solid #409eff;
      padding-bottom: 10px;
    }

    h2 {
      color: #666;
      margin-top: 30px;
      margin-bottom: 15px;
      font-size: 18px;
    }

    .test-section {
      margin-bottom: 30px;
      padding: 20px;
      background: #f9f9f9;
      border-radius: 6px;
      border-left: 4px solid #409eff;
    }

    .log {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      max-height: 500px;
      overflow-y: auto;
      margin-top: 15px;
      line-height: 1.6;
    }

    .log-entry {
      margin: 4px 0;
      padding: 2px 0;
    }

    .log-success {
      color: #2ecc71;
    }

    .log-error {
      color: #e74c3c;
    }

    .log-info {
      color: #3498db;
    }

    .log-warning {
      color: #f39c12;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .stat-card {
      background: white;
      padding: 15px;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
      text-align: center;
    }

    .stat-label {
      color: #666;
      font-size: 12px;
      margin-bottom: 8px;
    }

    .stat-value {
      color: #333;
      font-size: 24px;
      font-weight: bold;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }

    button.primary {
      background: #409eff;
      color: white;
    }

    button.primary:hover {
      background: #66b1ff;
    }

    button.danger {
      background: #f56c6c;
      color: white;
    }

    button.danger:hover {
      background: #f78989;
    }

    button.success {
      background: #67c23a;
      color: white;
    }

    button.success:hover {
      background: #85ce61;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .summary {
      margin-top: 30px;
      padding: 20px;
      background: #ecf5ff;
      border-radius: 6px;
      border-left: 4px solid #409eff;
    }

    .summary h3 {
      margin-bottom: 15px;
      color: #409eff;
    }

    .summary-stats {
      display: flex;
      gap: 30px;
      font-size: 16px;
    }

    .summary-passed {
      color: #67c23a;
      font-weight: bold;
    }

    .summary-failed {
      color: #f56c6c;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ§ª RuleQueryScheduler æµ‹è¯•å¥—ä»¶</h1>

    <div class="controls">
      <button class="primary" onclick="runAllTests()">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
      <button class="success" onclick="runTest1()">æµ‹è¯•1: æ—¶é—´é—´éš”è§£æ</button>
      <button class="success" onclick="runTest2()">æµ‹è¯•2: ä¼˜å…ˆé˜Ÿåˆ—æ’åº</button>
      <button class="success" onclick="runTest3()">æµ‹è¯•3: æ‰§è¡Œæ—¶æœº</button>
      <button class="success" onclick="runTest4()">æµ‹è¯•4: å¤±è´¥å¤„ç†</button>
      <button class="success" onclick="runTest5()">æµ‹è¯•5: åŠ¨æ€æ›´æ–°</button>
      <button class="danger" onclick="clearLog()">æ¸…é™¤æ—¥å¿—</button>
    </div>

    <div class="stats" id="stats">
      <div class="stat-card">
        <div class="stat-label">æµ‹è¯•é€šè¿‡</div>
        <div class="stat-value" id="passed">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">æµ‹è¯•å¤±è´¥</div>
        <div class="stat-value" id="failed">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">æ€»è®¡</div>
        <div class="stat-value" id="total">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">é€šè¿‡ç‡</div>
        <div class="stat-value" id="passRate">0%</div>
      </div>
    </div>

    <div class="log" id="log"></div>

    <div class="summary" id="summary" style="display: none;">
      <h3>ğŸ“Š æµ‹è¯•æ€»ç»“</h3>
      <div class="summary-stats">
        <span>æ€»è®¡: <span id="summaryTotal">0</span></span>
        <span class="summary-passed">âœ“ é€šè¿‡: <span id="summaryPassed">0</span></span>
        <span class="summary-failed">âœ— å¤±è´¥: <span id="summaryFailed">0</span></span>
      </div>
    </div>
  </div>

  <script type="module">
    import { RuleQueryScheduler } from './src/utils/RuleQueryScheduler.js'

    let testsPassed = 0
    let testsFailed = 0

    function log(message, type = 'info') {
      const logDiv = document.getElementById('log')
      const entry = document.createElement('div')
      entry.className = `log-entry log-${type}`

      const timestamp = new Date().toLocaleTimeString('zh-CN', { hour12: false })
      entry.textContent = `[${timestamp}] ${message}`

      logDiv.appendChild(entry)
      logDiv.scrollTop = logDiv.scrollHeight
    }

    function assert(condition, message) {
      if (condition) {
        testsPassed++
        log(`âœ“ ${message}`, 'success')
      } else {
        testsFailed++
        log(`âœ— ${message}`, 'error')
        throw new Error(`æ–­è¨€å¤±è´¥: ${message}`)
      }
      updateStats()
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms))
    }

    function updateStats() {
      document.getElementById('passed').textContent = testsPassed
      document.getElementById('failed').textContent = testsFailed
      const total = testsPassed + testsFailed
      document.getElementById('total').textContent = total
      const rate = total > 0 ? Math.round((testsPassed / total) * 100) : 0
      document.getElementById('passRate').textContent = rate + '%'
    }

    function showSummary() {
      const summary = document.getElementById('summary')
      summary.style.display = 'block'
      document.getElementById('summaryTotal').textContent = testsPassed + testsFailed
      document.getElementById('summaryPassed').textContent = testsPassed
      document.getElementById('summaryFailed').textContent = testsFailed
    }

    // Mock query executor
    function createMockExecutor(behavior = 'success') {
      const executionLog = []

      const executor = async (query) => {
        executionLog.push({ query, timestamp: Date.now() })

        await sleep(50) // Simulate network delay

        if (behavior === 'success') {
          return {
            result: [
              {
                metric: { instance: 'test-instance', job: 'test-job' },
                value: [Date.now() / 1000, '42']
              }
            ]
          }
        } else if (behavior === 'fail') {
          throw new Error('Query execution failed')
        } else if (behavior === 'mixed') {
          if (executionLog.length === 1) {
            throw new Error('First execution failed')
          }
          return {
            result: [
              {
                metric: { instance: 'test-instance', job: 'test-job' },
                value: [Date.now() / 1000, '100']
              }
            ]
          }
        }
      }

      executor.getLog = () => executionLog

      return executor
    }

    // Test 1: Interval Parsing
    window.runTest1 = async function() {
      log('=== æµ‹è¯• 1: æ—¶é—´é—´éš”è§£æ ===', 'info')

      const mockExecutor = createMockExecutor('success')
      const scheduler = new RuleQueryScheduler(mockExecutor)

      scheduler.addRule({ ruleId: 'rule-30s', query: 'up', interval: '30s' })
      scheduler.addRule({ ruleId: 'rule-1m', query: 'up', interval: '1m' })
      scheduler.addRule({ ruleId: 'rule-5m', query: 'up', interval: '5m' })
      scheduler.addRule({ ruleId: 'rule-invalid', query: 'up', interval: 'invalid' })

      const rule30s = scheduler.ruleMap.get('rule-30s')
      const rule1m = scheduler.ruleMap.get('rule-1m')
      const rule5m = scheduler.ruleMap.get('rule-5m')
      const ruleInvalid = scheduler.ruleMap.get('rule-invalid')

      assert(rule30s.intervalMs === 30 * 1000, 'è§£æ 30s æ­£ç¡®')
      assert(rule1m.intervalMs === 60 * 1000, 'è§£æ 1m æ­£ç¡®')
      assert(rule5m.intervalMs === 5 * 60 * 1000, 'è§£æ 5m æ­£ç¡®')
      assert(ruleInvalid.intervalMs === 30 * 1000, 'æ— æ•ˆé—´éš”é»˜è®¤ä¸º 30s')

      scheduler.stop()
      log('æµ‹è¯• 1 å®Œæˆ', 'success')
    }

    // Test 2: Priority Queue Ordering
    window.runTest2 = async function() {
      log('=== æµ‹è¯• 2: ä¼˜å…ˆé˜Ÿåˆ—æ’åº ===', 'info')

      const mockExecutor = createMockExecutor('success')
      const scheduler = new RuleQueryScheduler(mockExecutor)

      const now = Date.now()

      scheduler.addRule({ ruleId: 'rule-late', query: 'up{job="late"}', interval: '5m' })
      scheduler.addRule({ ruleId: 'rule-early', query: 'up{job="early"}', interval: '30s' })
      scheduler.addRule({ ruleId: 'rule-mid', query: 'up{job="mid"}', interval: '2m' })

      scheduler.ruleMap.get('rule-late').nextExecutionTime = now + 300000
      scheduler.ruleMap.get('rule-early').nextExecutionTime = now + 30000
      scheduler.ruleMap.get('rule-mid').nextExecutionTime = now + 120000

      scheduler.queue = []
      scheduler.enqueue(scheduler.ruleMap.get('rule-late'))
      scheduler.enqueue(scheduler.ruleMap.get('rule-early'))
      scheduler.enqueue(scheduler.ruleMap.get('rule-mid'))

      assert(scheduler.queue[0].ruleId === 'rule-early', 'é˜Ÿåˆ—æ’åº: æœ€æ—©çš„ä¼˜å…ˆ')
      assert(scheduler.queue[1].ruleId === 'rule-mid', 'é˜Ÿåˆ—æ’åº: ä¸­é—´å…¶æ¬¡')
      assert(scheduler.queue[2].ruleId === 'rule-late', 'é˜Ÿåˆ—æ’åº: æœ€æ™šæœ€å')

      scheduler.stop()
      log('æµ‹è¯• 2 å®Œæˆ', 'success')
    }

    // Test 3: Execution Timing
    window.runTest3 = async function() {
      log('=== æµ‹è¯• 3: æ‰§è¡Œæ—¶æœº ===', 'info')

      const mockExecutor = createMockExecutor('success')
      const scheduler = new RuleQueryScheduler(mockExecutor)

      scheduler.addRule({ ruleId: 'rule-2s', query: 'up', interval: '2s' })
      scheduler.start()

      log('ç­‰å¾…é¦–æ¬¡æ‰§è¡Œ...', 'info')
      await sleep(1500)
      const log1 = mockExecutor.getLog()
      assert(log1.length >= 1, 'è§„åˆ™å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œ')

      log('ç­‰å¾…ç¬¬äºŒæ¬¡æ‰§è¡Œ (2s é—´éš”)...', 'info')
      await sleep(2500)
      const log2 = mockExecutor.getLog()
      assert(log2.length >= 2, 'è§„åˆ™åœ¨é—´éš”åé‡æ–°æ‰§è¡Œ')

      if (log2.length >= 2) {
        const timeDiff = log2[1].timestamp - log2[0].timestamp
        assert(timeDiff >= 2000 && timeDiff <= 3000, `æ‰§è¡Œé—´éš”çº¦ä¸º 2s (å®é™…: ${timeDiff}ms)`)
      }

      scheduler.stop()
      log('æµ‹è¯• 3 å®Œæˆ', 'success')
    }

    // Test 4: Failure Handling
    window.runTest4 = async function() {
      log('=== æµ‹è¯• 4: å¤±è´¥å¤„ç†ä¸æ•°æ®æŒä¹…åŒ– ===', 'info')

      const mockExecutor = createMockExecutor('mixed')
      const scheduler = new RuleQueryScheduler(mockExecutor)

      let resultCallbackCount = 0
      let latestResults = null

      scheduler.onResult((results) => {
        resultCallbackCount++
        latestResults = results
        log(`ç»“æœå›è°ƒè§¦å‘ (ç¬¬ ${resultCallbackCount} æ¬¡)`, 'info')
      })

      scheduler.addRule({ ruleId: 'rule-failsafe', query: 'up', interval: '2s' })
      scheduler.start()

      log('ç­‰å¾…é¦–æ¬¡æ‰§è¡Œ (å°†å¤±è´¥)...', 'info')
      await sleep(1500)
      const rule = scheduler.ruleMap.get('rule-failsafe')
      assert(rule.lastResult === null, 'å¤±è´¥åæ— ç»“æœ')

      log('ç­‰å¾…ç¬¬äºŒæ¬¡æ‰§è¡Œ (å°†æˆåŠŸ)...', 'info')
      await sleep(2500)
      assert(rule.lastResult !== null, 'æˆåŠŸåå­˜å‚¨ç»“æœ')
      const successResult = rule.lastResult

      log('æ¨¡æ‹Ÿåç»­æ‰§è¡Œå¤±è´¥...', 'info')
      mockExecutor.behavior = 'fail'

      await sleep(2500)
      assert(rule.lastResult === successResult, 'å¤±è´¥åä¿ç•™ä¹‹å‰çš„ç»“æœ')
      assert(latestResults && latestResults.has('up'), 'ç»“æœæ˜ å°„åŒ…å«æŸ¥è¯¢')

      scheduler.stop()
      log('æµ‹è¯• 4 å®Œæˆ', 'success')
    }

    // Test 5: Dynamic Rule Updates
    window.runTest5 = async function() {
      log('=== æµ‹è¯• 5: åŠ¨æ€è§„åˆ™æ›´æ–° ===', 'info')

      const mockExecutor = createMockExecutor('success')
      const scheduler = new RuleQueryScheduler(mockExecutor)

      const alerts1 = [
        {
          labels: { alertname: 'Alert1' },
          rule: { name: 'Alert1', query: 'up{job="test1"}', duration: '30s' }
        },
        {
          labels: { alertname: 'Alert2' },
          rule: { name: 'Alert2', query: 'up{job="test2"}', duration: '1m' }
        }
      ]

      log('æ·»åŠ åˆå§‹å‘Šè­¦è§„åˆ™...', 'info')
      scheduler.updateRules(alerts1)
      assert(scheduler.ruleMap.size === 2, 'æ·»åŠ äº† 2 æ¡è§„åˆ™')
      assert(scheduler.ruleMap.has('Alert1'), 'Alert1 è§„åˆ™å­˜åœ¨')
      assert(scheduler.ruleMap.has('Alert2'), 'Alert2 è§„åˆ™å­˜åœ¨')

      const alerts2 = [
        {
          labels: { alertname: 'Alert1' },
          rule: { name: 'Alert1', query: 'up{job="test1"}', duration: '2m' }
        },
        {
          labels: { alertname: 'Alert3' },
          rule: { name: 'Alert3', query: 'up{job="test3"}', duration: '5m' }
        }
      ]

      log('æ›´æ–°å‘Šè­¦è§„åˆ™ (Alert1 é—´éš”æ”¹å˜, Alert2 ç§»é™¤, Alert3 æ·»åŠ )...', 'info')
      scheduler.updateRules(alerts2)
      assert(scheduler.ruleMap.size === 2, 'æ›´æ–°åä»ä¸º 2 æ¡è§„åˆ™')
      assert(scheduler.ruleMap.has('Alert1'), 'Alert1 ä»å­˜åœ¨')
      assert(!scheduler.ruleMap.has('Alert2'), 'Alert2 å·²ç§»é™¤')
      assert(scheduler.ruleMap.has('Alert3'), 'Alert3 å·²æ·»åŠ ')
      assert(scheduler.ruleMap.get('Alert1').interval === '2m', 'Alert1 é—´éš”å·²æ›´æ–°')

      scheduler.stop()
      log('æµ‹è¯• 5 å®Œæˆ', 'success')
    }

    // Run all tests
    window.runAllTests = async function() {
      testsPassed = 0
      testsFailed = 0
      clearLog()

      log('ğŸš€ å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯•...', 'info')

      try {
        await runTest1()
        await runTest2()
        await runTest3()
        await runTest4()
        await runTest5()

        log('', 'info')
        log('==================================', 'info')
        log(`æµ‹è¯•ç»“æœ: ${testsPassed} é€šè¿‡, ${testsFailed} å¤±è´¥`, 'info')
        log('==================================', 'info')

        if (testsFailed === 0) {
          log('âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡!', 'success')
        } else {
          log('âŒ éƒ¨åˆ†æµ‹è¯•å¤±è´¥!', 'error')
        }

        showSummary()
      } catch (error) {
        log(`âŒ æµ‹è¯•å¥—ä»¶å¤±è´¥: ${error.message}`, 'error')
        console.error(error)
      }
    }

    window.clearLog = function() {
      document.getElementById('log').innerHTML = ''
      document.getElementById('summary').style.display = 'none'
    }

    // Auto-run on load
    log('âœ¨ RuleQueryScheduler æµ‹è¯•å¥—ä»¶å·²åŠ è½½', 'success')
    log('ç‚¹å‡» "è¿è¡Œæ‰€æœ‰æµ‹è¯•" æŒ‰é’®å¼€å§‹æµ‹è¯•', 'info')
  </script>
</body>
</html>
